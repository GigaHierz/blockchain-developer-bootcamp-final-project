/**
 *
 * autogenerated by solidity-visual-auditor
 *
 * execute with:
 *  #> truffle test <path/to/this/test.js>
 *
 * */

const Nft = artifacts.require("../contracts/Nft.sol");

contract("Nft", (accounts) => {
  let contract;
  const creatorAddress = accounts[0];
  const firstAddress = accounts[1];
  const secondAddress = accounts[2];
  const thirdAddress = accounts[3];
  const fourthAddress = accounts[4];
  const externalAddress = accounts[5];

  /* create named accounts for contract roles */

  before(async () => {
    contract = await Nft.deployed();
  });

  describe("testgroup - security tests - description...", () => {
    //deploy a new contract
    before(async () => {
      /* before tests */
      const newNFT = await Nft.new();

      it("fails on initialize ...", async () => {
        return assertRevert(async () => {
          await newNFT.initialize();
        });
      });

      it("checks if method returns true", async () => {
        assert.isTrue(await newNFT.thisMethodShouldReturnTrue());
      });
    });

    beforeEach(async () => {
      /* before each tests */
    });
  });
  describe("deployment", async () => {
    it("deploys successfully", async () => {
      const address = contract.address;
      assert.notEqual(address, 0x0);
      assert.notEqual(address, "");
      assert.notEqual(address, null);
      assert.notEqual(address, undefined);
    });

    it("has a name", async () => {
      const name = await contract.name();
      assert.equal(name, "Nft");
    });

    it("has a symbol", async () => {
      const symbol = await contract.symbol();
      assert.equal(symbol, "Octopus");
    });
  });

  describe("minting", async () => {
    it("creates a new token", async () => {
      const result = await contract.mint(
        firstAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyV",
        "#111111"
      );
      const totalSupply = await contract.totalSupply();
      // SUCCESS
      assert.equal(totalSupply, 1);
      const event = result.logs[0].args;
      assert.equal(
        event.from,
        "0x0000000000000000000000000000000000000000",
        "from is correct"
      );
      assert.equal(event.to, firstAddress, "to is correct");
    });

    it("should  revert if cid already exist", async () => {
      await contract
        .mint(
          accounts[8],
          "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyV",
          "#222222"
        )
        .catch((error) => {
          assert.equal(
            error.message,
            "Returned error: VM Exception while processing transaction: revert Token already exists -- Reason given: Token already exists."
          );
        });
    });

    it("should  revert if color already exist", async () => {
      await contract
        .mint(
          accounts[8],
          "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC999",
          "#111111"
        )
        .catch((error) => {
          assert.equal(
            error.message,
            "Returned error: VM Exception while processing transaction: revert Color already exists -- Reason given: Color already exists."
          );
        });
    });

    it("should  revert if user tries to mint an OG Octopus twice", async () => {
      await contract
        .mint(
          firstAddress,
          "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCk12",
          "#222222"
        )
        .catch((error) => {
          assert.equal(
            error.message,
            "Returned error: VM Exception while processing transaction: revert User already  exists -- Reason given: User already  exists."
          );
        });
    });
  });

  describe("when I want to mint an NFT from any address", async () => {
    it("should be possible", async () => {
      await contract.mint(
        secondAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC444",
        "#222222"
      );

      let result = await contract.tokensOfOwner(secondAddress);

      assert.equal(result, 1);
    });
  });

  describe("when I want to get the tokenURI", async () => {
    it("should be returned", async () => {
      let result = await contract.tokenURI(1);

      assert.equal(
        result,
        "https://ipfs.io/ipfs/QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC444"
      );
    });

    describe("AND I request a tokenId that doesn't exists", async () => {
      it("it should be reverted", async () => {
        await contract.tokenURI(4).catch((error) => {
          assert.equal(
            error.message,
            "Returned error: VM Exception while processing transaction: revert ERC721Metadata: URI query for nonexistent token"
          );
        });
      });
    });
  });

  describe("when I do a handShake and the partner address doesn't exist", async () => {
    it("it should be reverted", async () => {
      await contract
        .handShake(
          secondAddress,
          accounts[6],
          "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC777",
          "#aaaaaa"
        )
        .catch((error) => {
          assert.equal(
            error.message,
            "Returned error: VM Exception while processing transaction: revert User doesn't exists -- Reason given: User doesn't exists."
          );
        });
    });
  });

  describe("get tokens of owner", async () => {
    it("lists tokens", async () => {
      let expected = [
        "https://ipfs.io/ipfs/QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyV",
        "https://ipfs.io/ipfs/QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyG",
        "https://ipfs.io/ipfs/QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC333",
        "https://ipfs.io/ipfs/QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC111",
      ];

      await contract.mint(
        thirdAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC555",
        "#aaaaaa"
      );
      await contract.mint(
        fourthAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC666",
        "#bbbbbb"
      );

      // Mint 3  tokens
      await contract.handShake(
        firstAddress,
        secondAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyG",
        "#cccccc"
      );
      await contract.handShake(
        firstAddress,
        thirdAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC333",
        "#dddddd"
      );
      await contract.handShake(
        firstAddress,
        fourthAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC111",
        "#123456"
      );

      await contract.tokensOfOwner(firstAddress).then(async (tokenIds) => {
        tokenIds.map(async (tokenId, index) => {
          await contract.tokenURI(tokenId).then((tokenUri) => {
            assert.equal(expected[index], tokenUri);
          });
        });
      });
    });
  });
});
