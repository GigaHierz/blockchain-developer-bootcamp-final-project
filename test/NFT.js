/**
 *
 * autogenerated by solidity-visual-auditor
 *
 * execute with:
 *  #> truffle test <path/to/this/test.js>
 *
 * */
const Nft = artifacts.require("../contracts/Nft.sol");

contract("Nft", (accounts) => {
  let contract;
  let creatorAddress = accounts[0];
  let firstOwnerAddress = accounts[1];
  let secondOwnerAddress = accounts[2];
  let externalAddress = accounts[3];
  let unprivilegedAddress = accounts[4];
  /* create named accounts for contract roles */

  before(async () => {
    contract = await Nft.deployed();

    /* before tests */
  });

  // Contract is initialized
  context("deployment", async () => {
    it("deploys successfully", async () => {
      const address = contract.address;
      assert.notEqual(address, 0x0);
      assert.notEqual(address, "");
      assert.notEqual(address, null);
      assert.notEqual(address, undefined);
    });

    it("has a name", async () => {
      const name = await contract.name();
      assert.equal(name, "Nft");
    });

    it("has a symbol", async () => {
      const symbol = await contract.symbol();
      assert.equal(symbol, "Octopus");
    });
  });

  // Test for minting an NFT
  context("minting", async () => {
    it("creates a new token", async () => {
      // SUCCESS
      await contract
        .mint(accounts[0], "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyV")
        .then((data) => {
          const event = data.logs[0].args;
          assert.equal(
            event.from,
            "0x0000000000000000000000000000000000000000",
            "from is correct"
          );
          assert.equal(event.to, accounts[0], "to is correct");
          assert.equal(event.tokenId.toString(), 0, "id is correct");
        });

      await contract
        .totalSupply()
        .then((totalSupply) => assert.equal(totalSupply, 1));

      // FAILURE: cannot mint same CID twice
      await contract
        .mint(accounts[0], "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyV")
        .then((result) => {
          assert.fail();
        })
        .catch((error) => {
          assert.notEqual(
            error.message,
            "assert.fail()",
            "You cannot mint the same CID twice"
          );
        });
    });
  });

  // Get all tokens that belng to contract
  xcontext("indexing", async () => {
    it("token List ", async () => {
      // Mint 3 more tokens
      await contract.mint(
        accounts[0],
        "QmZpzAuddjVVcVWAV4fgN4d5riPwdH52Y1RfFjNtknCJjv"
      );
      await contract.mint(
        accounts[0],
        "QmYYJ1mXNRUCHGnN2i9N9u1k9qfu3cPNVWmsrxYb3KXFT3"
      );
      await contract.mint(
        accounts[0],
        "Qmb26q9fZELfDYLUzbFr2pXsrnLaiBD8v5p3h8ZRFTHzC8"
      );
      const totalSupply = await contract.totalSupply();

      let token;
      let result = [];

      for (var i = 0; i <= totalSupply - 1; i++) {
        token = await contract.tokenURIs[i];
        result.push(token);
      }

      let expected = [
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyV",
        "QmZpzAuddjVVcVWAV4fgN4d5riPwdH52Y1RfFjNtknCJjv",
        "QmYYJ1mXNRUCHGnN2i9N9u1k9qfu3cPNVWmsrxYb3KXFT3",
        "Qmb26q9fZELfDYLUzbFr2pXsrnLaiBD8v5p3h8ZRFTHzC8",
      ];
      assert.equal(result.join(","), expected.join(","));
    });
  });

  // Get Tokens of OWner
  context("get tokenIds of owner", async () => {
    let expected = [
      "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyV",
      "QmZpzAuddjVVcVWAV4fgN4d5riPwdH52Y1RfFjNtknCJ11",
      "QmYYJ1mXNRUCHGnN2i9N9u1k9qfu3cPNVWmsrxYb3KXF22",
      "Qmb26q9fZELfDYLUzbFr2pXsrnLaiBD8v5p3h8ZRFTHz33",
      //   "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCk34",
    ];
    it("lists tokens", async () => {
      // Mint 3  tokens
      await contract.mint(
        accounts[0],
        "QmZpzAuddjVVcVWAV4fgN4d5riPwdH52Y1RfFjNtknCJ11"
      );
      await contract.mint(
        accounts[0],
        "QmYYJ1mXNRUCHGnN2i9N9u1k9qfu3cPNVWmsrxYb3KXF22"
      );
      await contract.mint(
        accounts[0],
        "Qmb26q9fZELfDYLUzbFr2pXsrnLaiBD8v5p3h8ZRFTHz33"
      );

      await contract
        .tokensOfOwner(accounts[0])
        .then((result) => assert.equal(result.join(","), expected.join(",")));
    });
  });

  // Check if minting function can be called by another address

  context("if message sender changes", async () => {
    it("lists their tokens", async () => {
      // Mint 3  tokens
      await contract.mint(
        accounts[1],
        "QmZpzAuddjVVcVWAV4fgN4d5riPwdH52Y1RfFjNtknCJ44"
      );
      await contract.mint(
        accounts[1],
        "QmYYJ1mXNRUCHGnN2i9N9u1k9qfu3cPNVWmsrxYb3KXF77"
      );
      await contract.mint(
        accounts[1],
        "Qmb26q9fZELfDYLUzbFr2pXsrnLaiBD8v5p3h8ZRFTHzhh"
      );

      let expected = [
        "QmZpzAuddjVVcVWAV4fgN4d5riPwdH52Y1RfFjNtknCJ44",
        "QmYYJ1mXNRUCHGnN2i9N9u1k9qfu3cPNVWmsrxYb3KXF77",
        "Qmb26q9fZELfDYLUzbFr2pXsrnLaiBD8v5p3h8ZRFTHzhh",
      ];

      await contract
        .tokensOfOwner(accounts[1])
        .then((result) => assert.equal(result.join(","), expected.join(",")));
    });
  });
});

// it("should revert if ...", () => {
//   return Nft.deployed()
//     .then((instance) => {
//       return instance.publicOrExternalContractMethod(argument1, argument2, {
//         from: externalAddress,
//       });
//     })
//     .then((result) => {
//       assert.fail();
//     })
//     .catch((error) => {
//       assert.notEqual(error.message, "assert.fail()", "Reason ...");
//     });
// });

// context("testgroup - security tests - description...", () => {
//   //deploy a new contract
//   before(async () => {
//     /* before tests */
//     const newNFT = await Nft.new();

//     it("fails on initialize ...", async () => {
//       return assertRevert(async () => {
//         await newNFT.initialize();
//       });
//     });

//     it("checks if method returns true", async () => {
//       assert.isTrue(await newNFT.thisMethodShouldReturnTrue());
//     });
//   });

//   beforeEach(async () => {
//     /* before each tests */
//   });
// });
