/**
 *
 * autogenerated by solidity-visual-auditor
 *
 * execute with:
 *  #> truffle test <path/to/this/test.js>
 *
 * */

const Nft = artifacts.require("../contracts/Nft.sol");

contract("Nft", (accounts) => {
  let contract;
  const creatorAddress = accounts[0];
  const firstAddress = accounts[1];
  const secondAddress = accounts[2];
  const thirdAddress = accounts[3];
  const fourthAddress = accounts[4];
  const externalAddress = accounts[5];

  /* create named accounts for contract roles */

  before(async () => {
    contract = await Nft.deployed();

    /* before tests */
  });

  beforeEach(async () => {
    /* before each context */
  });

  it("should revert if ...", () => {
    return Nft.deployed()
      .then((instance) => {
        return instance.publicOrExternalContractMethod(argument1, argument2, {
          from: externalAddress,
        });
      })
      .then((result) => {
        assert.fail();
      })
      .catch((error) => {
        assert.notEqual(error.message, "assert.fail()", "Reason ...");
      });
  });

  describe("testgroup - security tests - description...", () => {
    //deploy a new contract
    before(async () => {
      /* before tests */
      const newNFT = await Nft.new();

      it("fails on initialize ...", async () => {
        return assertRevert(async () => {
          await newNFT.initialize();
        });
      });

      it("checks if method returns true", async () => {
        assert.isTrue(await newNFT.thisMethodShouldReturnTrue());
      });
    });

    beforeEach(async () => {
      /* before each tests */
    });
  });
  describe("deployment", async () => {
    it("deploys successfully", async () => {
      const address = contract.address;
      assert.notEqual(address, 0x0);
      assert.notEqual(address, "");
      assert.notEqual(address, null);
      assert.notEqual(address, undefined);
    });

    it("has a name", async () => {
      const name = await contract.name();
      assert.equal(name, "Nft");
    });

    it("has a symbol", async () => {
      const symbol = await contract.symbol();
      assert.equal(symbol, "Octopus");
    });
  });

  describe("minting", async () => {
    it("creates a new token", async () => {
      const result = await contract.mint(
        firstAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyV"
      );
      const totalSupply = await contract.totalSupply();
      // SUCCESS
      assert.equal(totalSupply, 1);
      const event = result.logs[0].args;
      // console.log(event);
      // console.log(event.tokenId);
      // assert.equal(event.tokenId.toNumber(), 1, 'id is correct')
      assert.equal(
        event.from,
        "0x0000000000000000000000000000000000000000",
        "from is correct"
      );
      assert.equal(event.to, firstAddress, "to is correct");

      // FAILURE: cannot mint same uid twice
    });

    it("should  revert if user tries to mint the same uid twice", async () => {
      await contract
        .mint(firstAddress, "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyV")
        .catch((error) => {
          assert.equal(
            error.message,
            "Returned error: VM Exception while processing transaction: revert Object already exists -- Reason given: Object already exists."
          );
        });
    });

    it("should  revert if user tries to mint an OG Octopus twice", async () => {
      await contract
        .mint(firstAddress, "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCk12")
        .catch((error) => {
          assert.equal(
            error.message,
            "Returned error: VM Exception while processing transaction: revert User already  exists -- Reason given: User already  exists."
          );
        });
    });
  });

  describe("when I want to mint an NFT from any address", async () => {
    it("should be possible", async () => {
      await contract.mint(
        secondAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC444"
      );

      let result = await contract.tokensOfOwner(secondAddress);

      assert.equal(result, 1);
    });
  });

  describe("when I want to get the tokenURI", async () => {
    it("should be returned", async () => {
      let result = await contract.tokenURI(1);

      assert.equal(
        result,
        "https://ipfs.io/ipfs/QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC444"
      );
    });

    describe("AND I request a tokenId that doesn't exists", async () => {
      it("it should be reverted", async () => {
        await contract.tokenURI(4).catch((error) => {
          assert.equal(
            error.message,
            "Returned error: VM Exception while processing transaction: revert ERC721Metadata: URI query for nonexistent token"
          );
        });
      });
    });
  });

  describe("get tokens of owner", async () => {
    it("lists tokens", async () => {
      let expected = [
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyV",
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyG",
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC333",
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC111",
      ];

      // Mint 3  tokens
      await contract.handshake(
        firstAddress,
        secondAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHCkyG"
      );
      await contract.handshake(
        firstAddress,
        thirdAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC333"
      );
      await contract.handshake(
        firstAddress,
        fourthAddress,
        "QmWYeg2y9FKgsMYeWsr7kcpj6B6yq1Xx9P59LibSvHC111"
      );

      await contract.tokensOfOwner(firstAddress).then(async (tokenIds) => {
        tokenIds.map(async (tokenId, index) => {
          // console.log("tokenId", tokenId);
          await contract.tokenURI(tokenId).then((tokenUri) => {
            assert.equal(expected[index], tokenUri);
          });
        });
      });
    });
  });
});
